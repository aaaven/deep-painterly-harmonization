# target, selfie, x, y

# resize the selfie to designed size (w, h) and the design should provide its location (x, y)

import os
import math
from skimage import io, transform, img_as_float
import numpy as np
import cv2


def generate_mask(selfie):
    # maskRCNN

    return selfie_mask

def padding_selfie_mask(selfie_mask, x, y, target):
    # padding the selfie mask (generated by generate_mask) to target image_size
    self_img_c = transform.resize(selfie_mask, [h, w])
    rows_t, cols_t, h_t = target.shape
    c_mask = np.zeros((rows_t, cols_t))
    c_mask[y:y + h, x:x + w] = self_img_c
    for i in range(rows_t):
        for j in range(cols_t):
            if (c_mask[i,j]>0):
                c_mask[i,j]=1
            else:
                c_mask[i,j]=0
    return c_mask

def dialate_c_mask(c_mask, strength=35):
    # dialate the c_mask
    img1_1 = img_as_float(c_mask)
    h1 = img1_1.shape[0]
    w1 = img1_1.shape[1]
    r = strength
    img1_2 = cv2.GaussianBlur(img1_1, (r,r) ,r/3)
    c_mask_dialated = img1_2
    for i in range(h1):
        for j in range(w1):
            if (img1_2[i,j]>0.1):
                c_mask_dialated[i,j]=1
            else:
                c_mask_dialated[i,j]=0
    return c_mask_dialated

def Padding(selfie, x, y, target):
    # padding the selfie (generated by generate_mask) to target image_size
    self_img_c = transform.resize(selfie, [h, w])
    rows_t, cols_t, h_t = target.shape
    self_p = np.zeros((rows_t, cols_t, h_t))
    self_p[y:y + h, x:x + w, :] = self_img_c
    return self_p

def generate_native(c_mask, self_p, target):
    rows_t, cols_t, h_t = target.shape
    native = np.zeros((rows_t, cols_t, h_t))
    for i in range(3):
        native[:, :, i] = target[:, :, i] * (1 - c_mask) + self_p[:, :, i] * c_mask
    return native

def preprocessing(target, selfie, x, y):
    # generate mask
    selfie_mask = generate_mask(selfie)
    # padding mask
    c_mask = padding_selfie_mask(selfie_mask, x, y, target)
    # dialate the c_mask
    c_mask_dialated = dialate_c_mask(c_mask)
    # padding self
    self_p = Padding(selfie, x, y, target)
    # generate native image
    native = generate_native(c_mask, self_p, target)
    # generate the four inputs
    return c_mask, c_mask_dialated, native

def deep_harmony(c_mask, c_mask_dialated, native, target):

    if os.path.exists('data') == 0:
        os.mkdir('data')
    io.imsave('data/0_c_mask.jpg', c_mask)
    io.imsave('data/0_c_mask_dilated.jpg' , c_mask_dialated)
    io.imsave('data/0_naive.jpg', native)
    io.imsave('data/0_target.jpg', target)

    numImgs = 1
    numGpus = 1

    if os.path.exists('results') == 0:
        os.mkdir('results')

    N = int(math.ceil(float(numImgs) / numGpus))

    for j in range(1, numGpus + 1):
        cmd = ''
        for i in range(1, N + 1):
            idx = (i - 1) * numGpus + (j - 1)
            if idx >= 0 and idx < numImgs:
                print('Working on image idx = ', idx)
                part_cmd1 = ' th neural_gram.lua ' \
                            ' -content_image data/' + str(idx) + '_naive.jpg  ' \
                            ' -style_image   data/' + str(idx) + '_target.jpg ' \
                            ' -tmask_image   data/' + str(idx) + '_c_mask.jpg ' \
                            ' -mask_image    data/' + str(idx) + '_c_mask_dilated.jpg ' \
                            ' -gpu ' + str(j - 1) + ' -original_colors 0 -image_size 700 ' \
                            ' -output_image  results/' + str(idx) + '_inter_res.jpg' \
                            ' -print_iter 100 -save_iter 100 && '
                part_cmd2 = ' th neural_paint.lua ' \
                            ' -content_image data/' + str(idx) + '_naive.jpg ' \
                            ' -style_image   data/' + str(idx) + '_target.jpg ' \
                            ' -tmask_image   data/' + str(idx) + '_c_mask.jpg ' \
                            ' -mask_image    data/' + str(idx) + '_c_mask_dilated.jpg ' \
                            ' -cnnmrf_image  results/' + str(idx) + '_inter_res.jpg  ' \
                            ' -gpu ' + str(j - 1) + ' -original_colors 0 -image_size 700 ' \
                            ' -index ' + str(idx) + ' -wikiart_fn data/wikiart_output.txt ' \
                            ' -output_image  results/' + str(idx) + '_final_res.jpg' \
                            ' -print_iter 100 -save_iter 100 ' \
                            ' -num_iterations 1000 &&'
                cmd = cmd + part_cmd1 + part_cmd2
        cmd = cmd[1:len(cmd) - 1]
        print(cmd)
        os.system(cmd)

    final_res = io.imread('results/0_final_res.jpg')
    return final_res

def postprocessing(c_mask, target, native, final_res):
    #

    return final_result


def generate_styled_image(selfie, target, x, y):
    c_mask, c_mask_dialated, native = preprocessing(target, selfie, x, y)
    # deep harmony take four inputs:
    # c_mask, c_mask_dialated, native AND target togenerate output
    # and generate
    final_res = deep_harmony(c_mask, c_mask_dialated, native, target)
    # postprocessing
    # final_result = postprocessing(final_res)
    return final_res



selfie = io.imread('Archive/0.jpg')
target = io.imread('Archive/0_target.jpg')
selfie = selfie/255
target = target/255
x = 10
y = 300

w = 270
h = 400

selfie_mask = io.imread('Archive/00_c_mask.jpg')


final_result = generate_styled_image(selfie, target, x, y)
